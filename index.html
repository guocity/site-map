<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Path Tree Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the tree view - More Compact version */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
            font-size: 0.85rem; /* Reduced base font size */
        }
        .controls {
            margin-bottom: 0.75rem; /* Reduced margin */
        }
        .control-button {
            background-color: #e5e7eb; /* Gray-200 */
            color: #374151; /* Gray-700 */
            padding: 0.2rem 0.6rem; /* Reduced padding */
            border: none;
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.8rem; /* Reduced font size */
            font-weight: 500;
            cursor: pointer;
            margin-right: 0.4rem; /* Reduced margin */
            transition: background-color 0.2s;
        }
        .control-button:hover {
            background-color: #d1d5db; /* Gray-300 */
        }

        .tree-node {
            margin-left: 1rem; /* Reduced margin */
            padding-left: 0.3rem; /* Reduced padding */
            border-left: 1px solid #e5e7eb;
            margin-top: 0.05rem; /* Reduced margin */
            margin-bottom: 0.05rem; /* Reduced margin */
        }
        .node-header {
            display: flex;
            align-items: center;
            padding: 0.05rem 0; /* Reduced padding */
            cursor: default;
            position: relative; /* For absolute positioning of link */
        }
        .node-toggle {
            cursor: pointer;
            margin-right: 0.2rem; /* Reduced margin */
            user-select: none;
            width: 0.7rem; /* Reduced width */
            text-align: center;
            color: #6b7280;
            flex-shrink: 0;
            font-size: 0.6rem; /* Reduced font size */
        }
        .node-toggle.hidden {
             visibility: hidden;
        }
        .node-name {
            font-weight: 500;
            color: #1f2937;
            word-break: break-all;
            margin-right: 0.2rem; /* Reduced margin */
            font-size: 0.85em; /* Slightly smaller relative size */
        }
        /* Style for leaf node names */
        .leaf-node-name {
            color: #1e3a8a; /* Dark Blue (Blue-800) */
            font-size: 0.85em; /* Match node-name */
        }
        .node-count {
            color: #6b7280;
            font-size: 0.75em; /* Reduced font size */
            margin-left: 0.15rem; /* Reduced margin */
            white-space: nowrap;
        }
        .leaf-endpoint-marker {
             color: #6b7280;
             font-weight: normal;
             margin-right: 0.15rem; /* Reduced margin */
        }
        /* Status Indicator Styles */
        .status-indicator {
            font-size: 0.75em; /* Reduced font size */
            font-weight: 600;
            margin-left: 0.3rem; /* Reduced margin */
            padding: 0.05rem 0.25rem; /* Reduced padding */
            border-radius: 0.25rem;
            white-space: nowrap;
        }
        .status-ok {
            color: #059669; /* Emerald-600 */
        }
        .status-error {
            color: #dc2626; /* Red-600 */
            font-style: italic;
        }
        /* Go To URL Link */
        .go-to-link {
            color: #3b82f6; /* Blue-500 */
            text-decoration: none;
            margin-left: 0.3rem; /* Reduced margin */
            font-size: 1em; /* Reduced size */
            font-weight: bold;
            transition: color 0.2s;
        }
        .go-to-link:hover {
            color: #1d4ed8; /* Blue-700 */
        }

        .node-children {
             /* Starts expanded */
        }
        .node-children.collapsed {
            display: none;
        }
        /* Toggle icons */
        .node-toggle::before {
            content: '▼'; /* Expanded */
            display: inline-block;
            transition: transform 0.1s ease-in-out;
            vertical-align: middle;
        }
        .tree-node.collapsed > .node-header > .node-toggle::before {
            content: '▶'; /* Collapsed */
        }
        .host-root {
            background-color: white;
            padding: 0.5rem 0.75rem; /* Reduced padding */
            border-radius: 0.375rem;
            margin-bottom: 0.5rem; /* Reduced margin */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        /* Container for children within host root, for collapsing */
        .host-children-container {
             /* Starts expanded */
        }
        .host-children-container.collapsed {
             display: none;
        }
        .host-header {
            font-size: 0.9rem; /* Reduced font size */
            font-weight: 600;
            margin-bottom: 0.2rem; /* Reduced margin */
            color: #111827;
            /* Make host header behave like node header for alignment */
            display: flex;
            align-items: center;
            cursor: pointer; /* Ensure cursor indicates clickable */
        }
        /* Add toggle indicator for host */
        .host-header::before {
            content: '▼'; /* Expanded */
            display: inline-block;
            transition: transform 0.1s ease-in-out;
            vertical-align: middle;
            margin-right: 0.3rem; /* Reduced margin */
            font-size: 0.6rem; /* Match node toggle size */
            color: #6b7280; /* Match node toggle color */
            width: 0.7rem; /* Match node toggle width */
            text-align: center;
            flex-shrink: 0;
            user-select: none; /* Prevent text selection */
        }
        .host-root.collapsed > .host-header::before {
            content: '▶'; /* Collapsed */
        }
        /* Hide toggle if no children */
        .host-header.no-children::before {
            visibility: hidden;
        }
         .host-count {
            color: #6b7280;
            font-size: 0.8em; /* Reduced font size */
            margin-left: 0.2rem; /* Reduced margin */
            font-weight: 500;
        }
        .root-endpoint {
             margin-left: 1rem; /* Reduced margin */
             padding-left: 0.3rem; /* Reduced padding */
             border-left: 1px solid #e5e7eb;
             color: #6b7280;
             font-style: italic;
             padding-top: 0.05rem; /* Reduced padding */
             display: flex;
             align-items: center;
        }
    </style>
</head>
<body class="p-3 md:p-4"> <!-- Reduced padding -->
    <h1 class="text-lg font-semibold mb-3 text-gray-800">LG Fast Webspider Site View</h1> <!-- Reduced size/margin -->
    <div class="controls mb-2"> <!-- Added margin-bottom -->
        <button id="expand-all-btn" class="control-button">Expand All</button>
        <button id="collapse-all-btn" class="control-button">Collapse All</button>
        <button id="toggle-view-btn" class="control-button">Show Titles</button>
    </div>
    <!-- New Dropdown Container -->
    <div class="mb-3">
        <label for="json-file-select" class="mr-2 text-sm font-medium text-gray-700">Select Site Data:</label>
        <select id="json-file-select" class="p-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <option value="">Loading files...</option>
        </select>
    </div>
    <div id="tree-container">
        <p class="text-gray-500">Loading data...</p>
    </div>

    <script>
        // --- Global State ---
        let currentDisplayMode = 'url'; // 'url' or 'title'
        let currentTreeData = null; // Holds the structured tree data including collapse state
        let DEFAULT_JSON_PATH = 'json/choosealicense.com.json'; // Default remains, but selection overrides
        const MANIFEST_PATH = 'manifest.json'; // Path to the file list in the current directory

        // --- Data Loading ---
        async function fetchData(url) { // Use the passed URL
             const container = document.getElementById('tree-container');
             container.innerHTML = '<p class="text-gray-500">Loading data...</p>'; // Show loading message
             try {
                 const response = await fetch(url);
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const data = await response.json();
                 initializeTree(data);
             } catch (error) {
                 console.error(`Error fetching or parsing site data from ${url}:`, error);
                 if (container) {
                    container.innerHTML = `<p class="text-red-600">Error loading site data from ${url}. Check console for details.</p>`;
                 }
             }
        }

        // --- Populate JSON Files Dropdown ---
        async function populateJsonFilesDropdown() {
            const selectElement = document.getElementById('json-file-select');
            if (!selectElement) return;

            try {
                const response = await fetch(MANIFEST_PATH);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const filenames = await response.json();

                if (!Array.isArray(filenames)) {
                    throw new Error("Manifest content is not an array.");
                }

                selectElement.innerHTML = ''; // Clear loading message

                if (filenames.length === 0) {
                     selectElement.innerHTML = '<option value="">No files found</option>';
                     document.getElementById('tree-container').innerHTML = '<p class="text-gray-500">No data files listed in manifest.</p>';
                     return; // Stop if no files
                }

                filenames.forEach(filename => {
                    if (typeof filename === 'string' && filename.endsWith('.json')) {
                        const option = document.createElement('option');
                        const filePath = `json/${filename}`;
                        option.value = filePath;
                        option.textContent = filename.replace('.json', ''); // Display name without extension
                        selectElement.appendChild(option);

                        // Set initial selection based on DEFAULT_JSON_PATH
                        if (filePath === DEFAULT_JSON_PATH) {
                            option.selected = true;
                        }
                    } else {
                        console.warn(`Skipping invalid filename in manifest: ${filename}`);
                    }
                });

                // Add event listener for changes
                selectElement.addEventListener('change', (event) => {
                    const selectedFilePath = event.target.value;
                    if (selectedFilePath) {
                        // Update the default path (optional, but keeps it in sync)
                        DEFAULT_JSON_PATH = selectedFilePath;
                        // Fetch data for the newly selected file
                        fetchData(selectedFilePath);
                    }
                });

                // Trigger initial data load based on the (potentially updated) selected value
                const initialFilePath = selectElement.value;
                if (initialFilePath) {
                     fetchData(initialFilePath);
                } else if (filenames.length > 0) {
                    // Fallback: if default wasn't found, load the first file in the list
                    const firstFilePath = `json/${filenames[0]}`;
                    selectElement.value = firstFilePath; // Update dropdown selection
                    DEFAULT_JSON_PATH = firstFilePath; // Update default path
                    fetchData(firstFilePath);
                } else {
                     // This case should be handled by the 'No files found' check above
                     console.error("Dropdown populated but no valid initial file path found.");
                     document.getElementById('tree-container').innerHTML = '<p class="text-orange-500">Could not determine initial data file to load.</p>';
                }

            } catch (error) {
                console.error("Error fetching or processing manifest file:", error);
                selectElement.innerHTML = '<option value="">Error loading files</option>';
                // Update error message to reflect the new path
                document.getElementById('tree-container').innerHTML = `<p class="text-red-600">Error loading file list from ${MANIFEST_PATH}. Check console.</p>`;
            }
        }


        // --- Initialization ---
        function initializeTree(data) {
            try {
                // Build the tree structure, including default collapsed state (false)
                currentTreeData = buildTree(data);
                // Initial render based on the built tree and its state
                renderTree(currentTreeData, 'tree-container');

                // Remove previous listeners before adding new ones to prevent duplicates if re-initialized
                document.getElementById('expand-all-btn')?.removeEventListener('click', expandAll);
                document.getElementById('collapse-all-btn')?.removeEventListener('click', collapseAll);
                document.getElementById('toggle-view-btn')?.removeEventListener('click', toggleView);

                // Add event listeners for buttons
                document.getElementById('expand-all-btn')?.addEventListener('click', expandAll);
                document.getElementById('collapse-all-btn')?.addEventListener('click', collapseAll);
                document.getElementById('toggle-view-btn')?.addEventListener('click', toggleView);

            } catch (error) {
                 console.error("Error processing data or rendering tree:", error);
                document.getElementById('tree-container').innerHTML = `<p class="text-red-600">Error processing site data. Check console for details.</p>`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
             // Populate dropdown, which will trigger the initial fetchData
             populateJsonFilesDropdown();
             // DO NOT call fetchData here directly anymore
        });

        // --- Tree Building Logic ---
        function buildTree(data) {
            const hosts = {};

            if (!Array.isArray(data)) {
                console.error("Input data is not an array. Cannot build tree.", data);
                return hosts;
            }

            data.forEach(item => {
                let originalUrl, title, status;

                // Data extraction (same as before)
                if (Array.isArray(item) && item.length >= 3) {
                    [originalUrl, title, status] = item;
                } else if (typeof item === 'object' && item !== null && 'url' in item && 'title' in item && 'status' in item) {
                    originalUrl = item.url; title = item.title; status = item.status;
                } else {
                    console.warn(`Skipping invalid data item:`, item); return;
                }
                if (typeof originalUrl !== 'string' || typeof status === 'undefined') {
                     console.warn(`Skipping item with invalid extracted data: url=${originalUrl}, status=${status}`, item); return;
                }

                try {
                    const url = new URL(originalUrl);
                    const hostname = url.hostname;
                    let pathname = url.pathname;
                    const search = url.search;
                    const endsWithSlash = url.pathname !== '/' && url.pathname.endsWith('/');

                    if (!hosts[hostname]) {
                        // Initialize host node with isCollapsed state
                        hosts[hostname] = { children: {}, isEndpoint: false, urlCount: 0, name: hostname, isCollapsed: false };
                    }
                    hosts[hostname].urlCount++;

                    if (pathname.startsWith('/')) pathname = pathname.substring(1);
                    if (pathname.endsWith('/')) pathname = pathname.slice(0, -1);

                    let currentNode = hosts[hostname];

                    // Handle root path ('/' or empty after normalization)
                    if (pathname === '' || pathname === '/') {
                        if (search === '') {
                             hosts[hostname].isEndpoint = true;
                             hosts[hostname].status = status;
                             hosts[hostname].fullUrl = originalUrl;
                             hosts[hostname].title = title;
                             if (url.pathname === '/') hosts[hostname].isSlashEndpoint = true;
                        } else {
                            let queryNodeName = search;
                            if (!currentNode.children[queryNodeName]) {
                                // Initialize query node with isCollapsed state
                                currentNode.children[queryNodeName] = { children: {}, isEndpoint: true, name: queryNodeName, status: status, fullUrl: originalUrl, title: title, isCollapsed: false };
                            } else {
                                currentNode.children[queryNodeName].isEndpoint = true;
                                currentNode.children[queryNodeName].status = status;
                                currentNode.children[queryNodeName].fullUrl = originalUrl;
                                currentNode.children[queryNodeName].title = title;
                            }
                        }
                        return;
                    }

                    const segments = pathname.split('/');
                    segments.forEach((segment, index) => {
                        if (segment === '') return;

                        let nodeName = segment;
                        const isLastSegment = index === segments.length - 1;

                        if (isLastSegment && search) {
                            nodeName += search;
                        }

                        if (!currentNode.children[nodeName]) {
                             // Initialize path node with isCollapsed state
                            currentNode.children[nodeName] = { children: {}, isEndpoint: false, name: nodeName, isCollapsed: false };
                        }

                        if (isLastSegment) {
                            currentNode.children[nodeName].isEndpoint = true;
                            currentNode.children[nodeName].status = status;
                            currentNode.children[nodeName].fullUrl = originalUrl;
                            currentNode.children[nodeName].title = title;
                            if (endsWithSlash && !search) {
                                currentNode.children[nodeName].isSlashEndpoint = true;
                            }
                        }
                        currentNode = currentNode.children[nodeName];
                    });

                } catch (e) {
                    console.warn(`Skipping invalid URL: ${originalUrl}`, e);
                }
            });
            return hosts;
        }

        // --- Rendering Logic ---
        function renderTree(treeData, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; // Clear previous content

            const sortedHosts = Object.keys(treeData).sort();
            if (sortedHosts.length === 0) {
                 container.innerHTML = '<p class="text-gray-500">No valid URL data to display.</p>';
                 return;
            }

            sortedHosts.forEach(hostname => {
                const hostData = treeData[hostname];
                const hostRootDiv = document.createElement('div');
                // Apply 'collapsed' class based on data state
                hostRootDiv.className = `host-root ${hostData.isCollapsed ? 'collapsed' : ''}`;

                const hostHeaderDiv = document.createElement('div');
                hostHeaderDiv.className = 'host-header';
                let hostTitle = `Click to toggle children of ${hostname}`;
                 if (hostData.isEndpoint && hostData.fullUrl) {
                    hostTitle += `\nEndpoint: ${hostData.fullUrl}`;
                    if (hostData.title) hostTitle += `\nTitle: ${hostData.title}`;
                 }
                 hostHeaderDiv.title = hostTitle;

                const hostChildrenDiv = document.createElement('div');
                // Apply 'collapsed' class based on data state
                hostChildrenDiv.className = `host-children-container ${hostData.isCollapsed ? 'collapsed' : ''}`;

                // Render children recursively
                const childrenContent = renderNodeChildren(hostData, hostChildrenDiv); // Pass hostData
                const hasChildren = childrenContent && childrenContent.children.length > 0;

                if (!hasChildren) {
                    hostHeaderDiv.classList.add('no-children');
                }

                // Append header content (hostname, count, status, link)
                const hostNameSpan = document.createElement('span');
                hostNameSpan.textContent = hostname;
                hostHeaderDiv.appendChild(hostNameSpan);

                const hostCountSpan = document.createElement('span');
                hostCountSpan.className = 'host-count';
                hostCountSpan.textContent = `[${hostData.urlCount}]`;
                hostHeaderDiv.appendChild(hostCountSpan);

                // Add Status, Title (if applicable), and Go To link
                if (hostData.isEndpoint) {
                     if (currentDisplayMode === 'title' && hostData.title) {
                         const titleSpan = document.createElement('span');
                         titleSpan.textContent = `"${hostData.title}"`;
                         titleSpan.className = 'text-sm text-gray-600 ml-2 italic';
                         hostHeaderDiv.appendChild(titleSpan);
                     }
                     const statusSpan = createStatusIndicator(hostData.status);
                     hostHeaderDiv.appendChild(statusSpan);
                     const link = createGoToLink(hostData.fullUrl);
                     if (link) {
                        link.classList.add('ml-2');
                        hostHeaderDiv.appendChild(link);
                     }
                }

                hostRootDiv.appendChild(hostHeaderDiv);

                if (hasChildren) {
                    hostChildrenDiv.appendChild(childrenContent);
                    hostRootDiv.appendChild(hostChildrenDiv);
                }

                 // Add click listener to the host header for toggling state and view
                 hostHeaderDiv.addEventListener('click', (e) => {
                     if (e.target.closest('.go-to-link')) return; // Ignore clicks on the link

                     // Toggle the state in the data
                     hostData.isCollapsed = !hostData.isCollapsed;

                     // Toggle the classes on the DOM elements directly
                     const currentHostRoot = e.currentTarget.closest('.host-root');
                     const currentHostChildren = currentHostRoot?.querySelector('.host-children-container');
                     currentHostRoot?.classList.toggle('collapsed', hostData.isCollapsed);
                     currentHostChildren?.classList.toggle('collapsed', hostData.isCollapsed);
                 });

                 container.appendChild(hostRootDiv);
            });
        }

        // Helper to create status indicator (unchanged)
        function createStatusIndicator(status) {
            const statusSpan = document.createElement('span');
            statusSpan.className = 'status-indicator';
            if (status >= 200 && status < 300) {
                statusSpan.textContent = `✓ ${status}`; statusSpan.classList.add('status-ok');
            } else if (status) {
                statusSpan.textContent = `✗ ${status}`; statusSpan.classList.add('status-error');
            } else {
                statusSpan.textContent = '?'; statusSpan.classList.add('status-error');
            }
            return statusSpan;
        }

        // Helper to create Go To URL link (unchanged)
        function createGoToLink(url) {
            if (!url) return null;
            const link = document.createElement('a');
            link.href = url; link.target = "_blank"; link.rel = "noopener noreferrer";
            link.className = 'go-to-link'; link.textContent = '→'; link.title = `Go to ${url}`;
            link.addEventListener('click', (e) => e.stopPropagation());
            return link;
        }

        // Recursive function to render children
        function renderNodeChildren(parentNodeData, parentElement) { // Accept parentNodeData
            const childKeys = Object.keys(parentNodeData.children);
            if (childKeys.length === 0) return null;

            const childrenContainer = document.createElement('div');
             // Apply 'collapsed' class based on parent's state (this seems wrong, should be based on node's own state?)
             // Correction: The container itself doesn't get collapsed, the individual nodes within it do.
             // The parent's state controls the visibility of this *entire* container.
             // Let's remove the collapsed class here, it's handled by the parent node's logic.
            childrenContainer.className = 'node-children'; // Always start expanded relative to parent

            const sortedChildrenKeys = childKeys.sort();

            sortedChildrenKeys.forEach(nodeName => {
                const childNodeData = parentNodeData.children[nodeName];
                const hasGrandChildren = Object.keys(childNodeData.children).length > 0;
                const isLeafNode = childNodeData.isEndpoint && !hasGrandChildren;

                const nodeDiv = document.createElement('div');
                // Apply 'collapsed' class based on this node's data state
                nodeDiv.className = `tree-node ${childNodeData.isCollapsed ? 'collapsed' : ''}`;

                const nodeHeaderDiv = document.createElement('div');
                nodeHeaderDiv.className = 'node-header';
                let headerTitle = childNodeData.fullUrl || '';
                if (childNodeData.isEndpoint && childNodeData.title) {
                    headerTitle += `\nTitle: ${childNodeData.title}`;
                }
                if (headerTitle) nodeHeaderDiv.title = headerTitle.trim();

                const toggleSpan = document.createElement('span');
                toggleSpan.className = 'node-toggle';
                if (!hasGrandChildren) toggleSpan.classList.add('hidden');

                let nameElement;
                let displayName = nodeName;
                let statusSpan = null;
                let linkSpan = null;

                // Determine display name based on mode
                if (currentDisplayMode === 'title' && childNodeData.isEndpoint && childNodeData.title) {
                    displayName = childNodeData.title;
                } else if (!childNodeData.isEndpoint && hasGrandChildren) {
                     displayName += '/';
                }

                // Node Naming and Linking (mostly unchanged logic, uses displayName)
                if (isLeafNode) {
                    nameElement = document.createElement('a');
                    nameElement.href = childNodeData.fullUrl; nameElement.target = "_blank"; nameElement.rel = "noopener noreferrer";
                    nameElement.className = 'node-name leaf-node-name';
                    nameElement.textContent = displayName;
                    nameElement.addEventListener('click', e => e.stopPropagation());
                    statusSpan = createStatusIndicator(childNodeData.status);
                } else {
                    nameElement = document.createElement('span');
                    nameElement.className = 'node-name';
                    nameElement.textContent = displayName;
                    if (hasGrandChildren) nameElement.style.cursor = 'pointer';

                    if (childNodeData.isEndpoint) {
                        const leafMarker = document.createElement('span');
                        leafMarker.className = 'leaf-endpoint-marker';
                        if (currentDisplayMode === 'title' && childNodeData.title) {
                             leafMarker.textContent = `(${nodeName}) - `;
                             leafMarker.style.fontStyle = 'italic'; leafMarker.style.color = '#6b7280';
                        } else {
                             leafMarker.textContent = '- ';
                        }
                        nodeHeaderDiv.appendChild(leafMarker);
                        statusSpan = createStatusIndicator(childNodeData.status);
                        linkSpan = createGoToLink(childNodeData.fullUrl);
                    }
                }

                // Count Calculation (unchanged)
                const countSpan = document.createElement('span');
                countSpan.className = 'node-count';
                let displayCount = '';
                if (hasGrandChildren) {
                    let parentChildrenCount = 0, leafChildrenCount = 0;
                    Object.values(childNodeData.children).forEach(grandChild => {
                        const grandChildHasChildren = Object.keys(grandChild.children).length > 0;
                        if (grandChildHasChildren) parentChildrenCount++;
                        else if (grandChild.isEndpoint) leafChildrenCount++;
                    });
                    // Conditionally format the display count
                    if (leafChildrenCount > 0) {
                        displayCount = `[${parentChildrenCount}:${leafChildrenCount}]`;
                    } else {
                        displayCount = `[${parentChildrenCount}]`; // Omit :0 if leaf count is 0
                    }
                    countSpan.textContent = displayCount;
                }

                // Assemble Header (unchanged order)
                nodeHeaderDiv.appendChild(toggleSpan);
                nodeHeaderDiv.appendChild(nameElement);
                if (displayCount) nodeHeaderDiv.appendChild(countSpan);
                if (statusSpan) nodeHeaderDiv.appendChild(statusSpan);
                if (linkSpan) nodeHeaderDiv.appendChild(linkSpan);
                nodeDiv.appendChild(nodeHeaderDiv);

                // Recursive Call and Toggle Logic
                let grandChildrenContainer = null;
                if (hasGrandChildren) {
                    // Pass childNodeData to recursive call
                    grandChildrenContainer = renderNodeChildren(childNodeData, nodeDiv);
                    if (grandChildrenContainer) {
                         // Apply collapsed class based on childNodeData's state
                         grandChildrenContainer.classList.toggle('collapsed', childNodeData.isCollapsed);
                         nodeDiv.appendChild(grandChildrenContainer);

                        // Add Toggle Listener to header
                        nodeHeaderDiv.addEventListener('click', (e) => {
                            if (e.target.closest('.go-to-link') || e.target.tagName === 'A') return;

                            // Toggle state in the data
                            childNodeData.isCollapsed = !childNodeData.isCollapsed;

                            // Toggle classes on the DOM elements directly
                            const currentNodeDiv = e.currentTarget.closest('.tree-node');
                            const currentGrandChildrenContainer = currentNodeDiv?.querySelector('.node-children');
                            currentNodeDiv?.classList.toggle('collapsed', childNodeData.isCollapsed);
                            currentGrandChildrenContainer?.classList.toggle('collapsed', childNodeData.isCollapsed);
                        });
                    }
                }

                childrenContainer.appendChild(nodeDiv);
            }); // End forEach child

            return childrenContainer;
        }

        // --- State Update and Re-render Functions ---

        // Helper function to recursively set collapse state on data
        function setNodeCollapseState(nodeData, isCollapsed) {
            nodeData.isCollapsed = isCollapsed;
            Object.values(nodeData.children).forEach(child => {
                setNodeCollapseState(child, isCollapsed);
            });
        }

        function expandAll() {
            if (!currentTreeData) return;
            Object.values(currentTreeData).forEach(hostData => {
                setNodeCollapseState(hostData, false); // Set isCollapsed to false recursively
            });
            renderTree(currentTreeData, 'tree-container'); // Re-render the tree
        }

        function collapseAll() {
            if (!currentTreeData) return;
            Object.values(currentTreeData).forEach(hostData => {
                setNodeCollapseState(hostData, true); // Set isCollapsed to true recursively
            });
            renderTree(currentTreeData, 'tree-container'); // Re-render the tree
        }

        function toggleView() {
            const btn = document.getElementById('toggle-view-btn');
            if (currentDisplayMode === 'url') {
                currentDisplayMode = 'title';
                if (btn) btn.textContent = 'Show URLs';
            } else {
                currentDisplayMode = 'url';
                 if (btn) btn.textContent = 'Show Titles';
            }
            // Re-render the tree with the new mode, preserving collapse state from data
            if (currentTreeData) {
                 renderTree(currentTreeData, 'tree-container');
            } else {
                console.warn("Cannot toggle view: Tree data not available.");
            }
        }
    </script>
</body>
</html>
